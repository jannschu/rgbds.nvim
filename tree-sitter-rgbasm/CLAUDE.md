# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

`tree-sitter-rgbasm` is a Tree-sitter parser for RGBASM (Game Boy assembly language used by RGBDS). The parser provides syntax highlighting, indentation, and code folding for Game Boy development in editors like Neovim.

**Current Status**: ~70-75% RGBASM spec coverage, production-ready with 80 corpus tests passing.

## Build and Test Commands

### Prerequisites

```bash
npm install -g tree-sitter-cli
```

### Essential Commands

```bash
# Generate parser from grammar.js (run after any grammar changes)
tree-sitter generate

# Run all tests
tree-sitter test

# Run specific test by pattern
tree-sitter test --include "test name pattern"

# Update test expectations after grammar changes
tree-sitter test --update

# Interactive playground for debugging
tree-sitter playground

# Parse a single file to see syntax tree
tree-sitter parse path/to/file.asm

# Build library
make

# Clean build artifacts
make clean
```

### Development Workflow

1. Edit `grammar.js` to add/modify grammar rules
2. Run `tree-sitter generate` to regenerate parser
3. Add/update tests in `test/corpus/`
4. Run `tree-sitter test` to verify
5. Use `tree-sitter playground` for visual debugging

## Architecture

### Parser Components

**grammar.js** - Main grammar definition (JavaScript DSL)

- Defines all syntax rules using Tree-sitter grammar DSL
- Structured hierarchically: `source_file` → `section_block` → `global_label_block` → `local_label_block` → statements
- External scanner tokens defined at top for complex lexing scenarios
- Binary operators defined in `binary_ops()` function with precedence levels 1-8

**src/scanner.c** - Custom external scanner (C)

- Handles complex tokens that Tree-sitter's internal lexer can't parse
- Key tokens: `MACRO_ARG`, `LABEL_TOKEN`, `REGISTER_TOKEN`, `INSTRUCTION_TOKEN`, `RAW_MACRO_MODE`
- Implements stateful scanning for raw macro argument mode
- Distinguishes instructions from identifiers by checking against SM83/Z80 opcode list
- Identifies labels by detecting `identifier:` pattern (no whitespace before colon)

**src/parser.c** - Generated parser (DO NOT EDIT MANUALLY)

- Auto-generated by `tree-sitter generate`
- Regenerated every time grammar.js is modified

### File Structure

The grammar uses a **hierarchical block structure** (WIP - currently implemented but indentation queries incomplete):

```
source_file
├── _non_section_statement (directives/blocks before any SECTION)
├── section_block (SECTION directive + contents)
│   ├── _section_statement (directives, instructions without labels)
│   ├── global_label_block (global_label + contents)
│   │   ├── _section_statement (directives, instructions)
│   │   ├── local_label_block (local_label + contents)
│   │   │   └── _section_statement (directives, instructions)
```

**Key Implementation Details** (grammar.js:33-83):

- `source_file`: `repeat(_non_section_statement)` followed by `repeat(section_block)`
- `section_block`: Section header + `repeat(_section_statement)` + `repeat(global_label_block)`
- `global_label_block`: Label header + `repeat(_section_statement)` + `repeat(local_label_block)`
- `local_label_block`: Label header + `repeat(_section_statement)`

This structure creates **parent-child relationships** between labels and their bodies, enabling proper indentation support via Tree-sitter's indent queries. See INDENTS.md for detailed design rationale.

### Expression Precedence

RGBASM expressions use 8 precedence levels (matching rgbasm.5 specification):

1. `**` (exponentiation) - right-associative
2. `*`, `/`, `%`
3. `<<`, `>>`, `>>>`
4. `&`, `|`, `^`
5. `++` (string concatenation), `+`, `-`
6. `===`, `!==`, `==`, `!=`, `<`, `<=`, `>`, `>=`
7. `&&`
8. `||`

Unary operators (`+`, `-`, `!`, `~`) have higher precedence than all binary operators.

### External Scanner Tokens

The external scanner (src/scanner.c) provides specialized token recognition:

- **LABEL_TOKEN**: Identifier immediately followed by `:` (no whitespace) - becomes a label
- **INSTRUCTION_TOKEN**: Matches SM83/Z80 instruction mnemonics (LD, ADD, JP, etc.)
- **REGISTER_TOKEN**: CPU registers (A, B, C, D, E, H, L, AF, BC, DE, HL, SP, PC)
- **MACRO_ARG**: Raw macro arguments in `\1`, `\<...>` syntax - lexed in special raw mode
- **RAW_MACRO_MODE**: Zero-width token that toggles raw lexing mode for macro expansion

This design allows the parser to handle context-sensitive tokens that would be ambiguous in a pure grammar.

## Neovim Integration

### Parser Registration

- `plugin/rgbasm.lua`: Filetype detection for `.asm`, `.inc`, `.gbz80`, `.z80` files
- `ftplugin/rgbasm.lua`: Filetype-specific settings (comment string, indentation)

### Queries

- `queries/highlights.scm`: Syntax highlighting rules (semantic tokens)
- `queries/indents.scm`: Indentation rules for auto-indent
- `queries/folds.scm`: Code folding for block directives (IF/REPT/FOR/MACRO/SECTION)

## Testing

### Test Organization

Tests are organized by feature in `test/corpus/`:

- `blocks.txt` - IF/ELIF/ELSE, REPT, FOR, MACRO blocks
- `expressions.txt` - Operators, precedence, functions
- `literals.txt` - Numbers (hex/bin/oct), fixed-point, graphics
- `strings.txt` - String literals, escapes, interpolation
- `directives.txt` - SECTION, DB, DW, DEF, etc.
- `instructions.txt` - Z80 opcodes and operands
- `labels.txt` - Global, local (`.local`), anonymous (`:`, `:+`, `:-`) labels
- `macros.txt` - Macro definitions and calls
- `interpolation.txt` - String and identifier interpolation (`{name}`, `{d:value}`)
- `rgbds.txt` - Real-world RGBDS code examples

### Test Format

```
================================================================================
Test Name: brief description
================================================================================

; Test input (RGBASM code)
DEF X = 1 + 2

---

(source_file
  (directive
    (def_directive
      (keyword)
      (name (identifier))
      (assign_type)
      (value (expression)))))
```

## Language Bindings

The parser includes bindings for multiple languages:

- **Node.js**: `bindings/node/` - Using node-addon-api and node-gyp-build
- **Python**: `bindings/python/` - Using Python C extension API
- **Rust**: `bindings/rust/` - Using cc crate
- **Go**: `bindings/go/` - Using cgo
- **Swift**: `bindings/swift/` - Using Swift/C interop
- **C**: `bindings/c/` - Header file and pkg-config

Build configuration: `binding.gyp` (node-gyp) for Node.js native addon.

## Key Design Decisions

### Block Directive Structure (Current Limitation)

Block directives (IF/REPT/FOR/MACRO) are currently **not fully integrated into the grammar** due to architectural challenges (grammar.js:419-505 commented out). They can appear anywhere (preprocessor-style) and may "mask" section starts:

```asm
IF 0
SECTION "A"
ELSE
SECTION "B"
ENDC
  nop
```

**Problem**: This doesn't fit cleanly into the `section_block` → `global_label_block` → `local_label_block` hierarchy without allowing blocks to contain section-level constructs.

**Solution**: See PREPROCESSOR_PATTERN_ANALYSIS.md for the tree-sitter-c pattern that solves this by generating context-specific versions of block rules (e.g., `if_block`, `if_block_in_section`, `if_block_in_label`).

### Macro Argument Lexing

Macro arguments (`\1`, `\<expr>`) use a special "raw mode" where normal lexing rules don't apply. This matches RGBDS behavior where macro args are lexed verbatim until delimiter. The external scanner tracks `in_raw_macro_mode` state and emits `MACRO_ARG_END` at line boundaries.

### Interpolation Scope

String interpolation (`{name}`, `{fmt:name}`) works in:

- String literals: `"Hello {name}"`
- Interpolatable identifiers: `{prefix}_SUFFIX`

**Not supported** in expression contexts (by design - Tree-sitter parses structurally, RGBDS expands during lexing).

### EQUS Non-Expansion

The parser does **not** expand EQUS symbols:

```asm
DEF foo EQUS "bar"
foo    ; Parsed as identifier 'foo', not expanded to 'bar'
```

This is by design - Tree-sitter operates on raw text without semantic analysis.

## Indentation Support (Work in Progress)

The grammar implements a **hierarchical block structure** specifically to support Tree-sitter-based indentation in editors like Neovim. See **INDENTS.md** for comprehensive design documentation.

### Current Status

**Implemented** (grammar.js):

- Hierarchical structure: `source_file` → `section_block` → `global_label_block` → `local_label_block`
- Parent-child relationships between labels and their statement bodies
- Block directives marked but not integrated into hierarchy

**Incomplete** (queries/indents.scm):

- Missing `@indent.begin` for `global_label_block` and `local_label_block`
- Only has basic block construct indentation (IF/MACRO/REPT/FOR/UNION/LOAD)
- Section directive marked as `@indent.zero` but section_block not configured

### Why This Structure?

Tree-sitter's indent algorithm only processes **parent-child relationships**, not sibling relationships. The original flat structure parsed labels and following instructions as siblings, making indentation impossible to express in queries:

```
(source_file
  (label_definition ...)    ← Sibling
  (instruction_line ...))   ← Sibling (can't indent relative to previous sibling)
```

The hierarchical structure makes instructions **children** of labels:

```
(source_file
  (global_label_block       ← Parent
    (global_label ...)
    (instruction_line ...))) ← Child (can indent via @indent.begin)
```

### Indentation Without Syntax

Important: The hierarchical structure **does not make indentation syntactically significant**. Blocks are delimited by explicit syntax:

- `SECTION` directives start section blocks
- Global labels start global blocks (until next global label or section)
- Local labels start local blocks (until next label)

This keeps the parser compatible with RGBASM's spec where indentation is not part of the grammar.

### Future: Arbitrary Indentation-Driven Nesting

INDENTS.md (section 6.6) documents a possible future enhancement using `INDENT`/`DEDENT` tokens (Python-style) to support arbitrary label nesting based purely on indentation. This would require:

- External scanner support for indent stack tracking
- New external tokens (`INDENT`, `DEDENT`)
- Generic `indent_block` grammar rules

This is **not currently implemented** due to complexity and divergence from RGBASM spec.

## Known Limitations

See PLAN.md for detailed edge cases:

1. **Interpolatable identifiers with prefix**: `ITEM_{d:NUM}` doesn't parse correctly (prefix before `{` not supported)
2. **Raw identifiers in interpolation**: `{#if}` not recognized (should reference keyword-escaped symbol)
3. **Block directives**: IF/REPT/FOR/MACRO not fully integrated into section hierarchy (see below)
4. **Indent queries incomplete**: `queries/indents.scm` needs rules for label blocks

### Solution for Block Directives

**PREPROCESSOR_PATTERN_ANALYSIS.md** contains a comprehensive analysis of how tree-sitter-c solves the "preprocessor can appear anywhere" problem (which RGBASM's IF/REPT/FOR/MACRO blocks have). The key pattern:

1. Create a helper function that generates context-specific versions of block rules
2. Each version contains different content types (e.g., `if_block` at top-level vs `if_block_in_section`)
3. Include block directives as alternatives in every grammar context where they can appear
4. Use aliasing to maintain consistent node names for queries

This pattern would allow IF blocks to contain SECTION directives without "masking" problems, properly representing RGBASM's preprocessor semantics.

## Outstanding Work Items

Based on FIXMEs in grammar.js and incomplete features:

1. **Indentation queries** (HIGH PRIORITY) - queries/indents.scm needs:

   ```scm
   (global_label_block) @indent.begin
   (local_label_block) @indent.begin
   (section_block) @indent.zero  ; or appropriate handling
   ```

2. **Block directive integration** (grammar.js:419-505) - Apply tree-sitter-c pattern:

   - Create `rgbasmBlock(suffix, content)` helper function
   - Generate context-specific versions (e.g., `if_block_in_section`)
   - Include as alternatives in `_section_statement`, etc.

3. **POPS/PUSHS implementation** (grammar.js:41) - Section stack directives

4. **ENDSECTION directive** (grammar.js:46) - Optional section terminator

5. **Anonymous label handling** (grammar.js:90) - `:` labels within statement context

## Reference Documentation

- **RGBASM Specification**: Official RGBDS docs at <https://rgbds.gbdev.io/>
- **AGENTS.md**: Detailed development guidelines and architecture
- **PLAN.md**: Development roadmap, edge cases, future enhancements
- **INDENTS.md**: Complete indentation design documentation (hierarchical structure, nvim-treesitter integration, INDENT/DEDENT future design)
- **PREPROCESSOR_PATTERN_ANALYSIS.md**: Analysis of tree-sitter-c's preprocessor handling and application to RGBASM
- **README.md**: User-facing documentation and installation
- Always ensure there is a timeout when calling the parser as infinite loops might occur.
- Do not add (ERROR ...) output to tests unless they are _expected_ to fail.
- Do never remove test cases that show a bug, maybe split the test if appropiate, but that is what tests are for.